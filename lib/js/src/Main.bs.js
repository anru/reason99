// Generated by BUCKLESCRIPT VERSION 2.2.3, PLEASE EDIT WITH CARE
'use strict';

var Caml_obj = require("bs-platform/lib/js/caml_obj.js");

function last_element(_ll) {
  while(true) {
    var ll = _ll;
    if (ll) {
      var rest = ll[1];
      if (rest) {
        _ll = rest;
        continue ;
        
      } else {
        return /* Some */[ll[0]];
      }
    } else {
      return /* None */0;
    }
  };
}

function last_two(_ll) {
  while(true) {
    var ll = _ll;
    if (ll) {
      var rest = ll[1];
      if (rest) {
        if (rest[1]) {
          _ll = rest;
          continue ;
          
        } else {
          return /* Some */[/* tuple */[
                    ll[0],
                    rest[0]
                  ]];
        }
      } else {
        _ll = rest;
        continue ;
        
      }
    } else {
      return /* None */0;
    }
  };
}

function at(_k, _ll) {
  while(true) {
    var ll = _ll;
    var k = _k;
    if (k !== 0) {
      if (ll) {
        _ll = ll[1];
        _k = k - 1 | 0;
        continue ;
        
      } else {
        return /* None */0;
      }
    } else if (ll) {
      return /* Some */[ll[0]];
    } else {
      return /* None */0;
    }
  };
}

function length(ll) {
  if (ll) {
    return length(ll[1]) + 1 | 0;
  } else {
    return 0;
  }
}

function reverse(ll) {
  var _acc = ll;
  var _result = /* [] */0;
  while(true) {
    var result = _result;
    var acc = _acc;
    if (acc) {
      _result = /* :: */[
        acc[0],
        result
      ];
      _acc = acc[1];
      continue ;
      
    } else {
      return result;
    }
  };
}

function is_palindrome(ll) {
  return Caml_obj.caml_equal(reverse(ll), ll);
}

function concat(a, b) {
  var _a = reverse(a);
  var _b = b;
  while(true) {
    var b$1 = _b;
    var a$1 = _a;
    if (a$1) {
      var rest = a$1[1];
      var x = a$1[0];
      if (rest) {
        _b = /* :: */[
          x,
          b$1
        ];
        _a = rest;
        continue ;
        
      } else {
        return /* :: */[
                x,
                b$1
              ];
      }
    } else {
      return b$1;
    }
  };
}

function flatten(ll) {
  var flattenify = function (_ll, _acc) {
    while(true) {
      var acc = _acc;
      var ll = _ll;
      if (ll) {
        var match = ll[0];
        if (match.tag) {
          _ll = concat(match[0], ll[1]);
          continue ;
          
        } else {
          _acc = /* :: */[
            match[0],
            acc
          ];
          _ll = ll[1];
          continue ;
          
        }
      } else {
        return acc;
      }
    };
  };
  return reverse(flattenify(ll, /* [] */0));
}

function flatten2(ll) {
  var aux = function (_ll, _acc) {
    while(true) {
      var acc = _acc;
      var ll = _ll;
      if (ll) {
        var match = ll[0];
        if (match.tag) {
          _acc = aux(match[0], acc);
          _ll = ll[1];
          continue ;
          
        } else {
          _acc = /* :: */[
            match[0],
            acc
          ];
          _ll = ll[1];
          continue ;
          
        }
      } else {
        return acc;
      }
    };
  };
  return reverse(aux(ll, /* [] */0));
}

exports.last_element = last_element;
exports.last_two = last_two;
exports.at = at;
exports.length = length;
exports.reverse = reverse;
exports.is_palindrome = is_palindrome;
exports.concat = concat;
exports.flatten = flatten;
exports.flatten2 = flatten2;
/* No side effect */
