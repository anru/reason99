// Generated by BUCKLESCRIPT VERSION 2.2.3, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");

function last_element(_ll) {
  while(true) {
    var ll = _ll;
    if (ll) {
      var rest = ll[1];
      if (rest) {
        _ll = rest;
        continue ;
        
      } else {
        return /* Some */[ll[0]];
      }
    } else {
      return /* None */0;
    }
  };
}

function last_two(_ll) {
  while(true) {
    var ll = _ll;
    if (ll) {
      var rest = ll[1];
      if (rest) {
        if (rest[1]) {
          _ll = rest;
          continue ;
          
        } else {
          return /* Some */[/* tuple */[
                    ll[0],
                    rest[0]
                  ]];
        }
      } else {
        _ll = rest;
        continue ;
        
      }
    } else {
      return /* None */0;
    }
  };
}

function at(_k, _ll) {
  while(true) {
    var ll = _ll;
    var k = _k;
    if (k !== 0) {
      if (ll) {
        _ll = ll[1];
        _k = k - 1 | 0;
        continue ;
        
      } else {
        return /* None */0;
      }
    } else if (ll) {
      return /* Some */[ll[0]];
    } else {
      return /* None */0;
    }
  };
}

function length(ll) {
  if (ll) {
    return length(ll[1]) + 1 | 0;
  } else {
    return 0;
  }
}

function reverse(ll) {
  var _acc = ll;
  var _result = /* [] */0;
  while(true) {
    var result = _result;
    var acc = _acc;
    if (acc) {
      _result = /* :: */[
        acc[0],
        result
      ];
      _acc = acc[1];
      continue ;
      
    } else {
      return result;
    }
  };
}

function is_palindrome(ll) {
  return Caml_obj.caml_equal(reverse(ll), ll);
}

function concat(a, b) {
  var _a = reverse(a);
  var _b = b;
  while(true) {
    var b$1 = _b;
    var a$1 = _a;
    if (a$1) {
      var rest = a$1[1];
      var x = a$1[0];
      if (rest) {
        _b = /* :: */[
          x,
          b$1
        ];
        _a = rest;
        continue ;
        
      } else {
        return /* :: */[
                x,
                b$1
              ];
      }
    } else {
      return b$1;
    }
  };
}

function flatten(ll) {
  var aux = function (_ll, _acc) {
    while(true) {
      var acc = _acc;
      var ll = _ll;
      if (ll) {
        var match = ll[0];
        if (match.tag) {
          _ll = concat(match[0], ll[1]);
          continue ;
          
        } else {
          _acc = /* :: */[
            match[0],
            acc
          ];
          _ll = ll[1];
          continue ;
          
        }
      } else {
        return acc;
      }
    };
  };
  return reverse(aux(ll, /* [] */0));
}

function flatten2(ll) {
  var aux = function (_ll, _acc) {
    while(true) {
      var acc = _acc;
      var ll = _ll;
      if (ll) {
        var match = ll[0];
        if (match.tag) {
          _acc = aux(match[0], acc);
          _ll = ll[1];
          continue ;
          
        } else {
          _acc = /* :: */[
            match[0],
            acc
          ];
          _ll = ll[1];
          continue ;
          
        }
      } else {
        return acc;
      }
    };
  };
  return reverse(aux(ll, /* [] */0));
}

function compress(ll) {
  var aux = function (_ll, _acc) {
    while(true) {
      var acc = _acc;
      var ll = _ll;
      if (ll) {
        var rest = ll[1];
        var x = ll[0];
        if (acc) {
          if (Caml_obj.caml_equal(x, acc[0])) {
            _acc = /* :: */[
              x,
              acc[1]
            ];
            _ll = rest;
            continue ;
            
          } else {
            _acc = /* :: */[
              x,
              acc
            ];
            _ll = rest;
            continue ;
            
          }
        } else {
          _acc = /* :: */[
            x,
            /* [] */0
          ];
          _ll = rest;
          continue ;
          
        }
      } else {
        return acc;
      }
    };
  };
  return reverse(aux(ll, /* [] */0));
}

function compress2(_ll) {
  while(true) {
    var ll = _ll;
    if (ll) {
      var t = ll[1];
      if (t) {
        var a = ll[0];
        var match = Caml_obj.caml_equal(a, t[0]);
        if (match !== 0) {
          _ll = t;
          continue ;
          
        } else {
          return /* :: */[
                  a,
                  compress2(t)
                ];
        }
      } else {
        return ll;
      }
    } else {
      return ll;
    }
  };
}

function pack(ll) {
  var aux = function (_ll, _acc) {
    while(true) {
      var acc = _acc;
      var ll = _ll;
      if (ll) {
        var rest = ll[1];
        var x = ll[0];
        var exit = 0;
        if (acc) {
          var f = acc[0];
          if (f && Caml_obj.caml_equal(x, f[0])) {
            _acc = /* :: */[
              /* :: */[
                x,
                f
              ],
              acc[1]
            ];
            _ll = rest;
            continue ;
            
          } else {
            exit = 1;
          }
        } else {
          exit = 1;
        }
        if (exit === 1) {
          _acc = /* :: */[
            /* :: */[
              x,
              /* [] */0
            ],
            acc
          ];
          _ll = rest;
          continue ;
          
        }
        
      } else {
        return acc;
      }
    };
  };
  return reverse(aux(ll, /* [] */0));
}

function encode_with_pack_rl(ll) {
  var packed_ll = pack(ll);
  var aux = function (l) {
    if (l) {
      var t = l[0];
      if (t) {
        return /* :: */[
                /* tuple */[
                  length(t),
                  t[0]
                ],
                aux(l[1])
              ];
      } else {
        return /* [] */0;
      }
    } else {
      return /* [] */0;
    }
  };
  return aux(packed_ll);
}

function encode_rl(ll) {
  var aux = function (_l, _count) {
    while(true) {
      var count = _count;
      var l = _l;
      if (l) {
        var t = l[1];
        var a = l[0];
        if (t) {
          var match = Caml_obj.caml_equal(a, t[0]);
          if (match !== 0) {
            _count = count + 1 | 0;
            _l = t;
            continue ;
            
          } else {
            return /* :: */[
                    /* tuple */[
                      count,
                      a
                    ],
                    aux(t, 1)
                  ];
          }
        } else {
          return /* :: */[
                  /* tuple */[
                    count,
                    a
                  ],
                  /* [] */0
                ];
        }
      } else {
        return /* [] */0;
      }
    };
  };
  return aux(ll, 1);
}

function encode_rle(ll) {
  var mk = function (count, v) {
    var match = +(count === 1);
    if (match !== 0) {
      return /* One */Block.__(0, [v]);
    } else {
      return /* Many */Block.__(1, [
                count,
                v
              ]);
    }
  };
  var aux = function (_l, _count) {
    while(true) {
      var count = _count;
      var l = _l;
      if (l) {
        var t = l[1];
        var a = l[0];
        if (t) {
          var match = Caml_obj.caml_equal(a, t[0]);
          if (match !== 0) {
            _count = count + 1 | 0;
            _l = t;
            continue ;
            
          } else {
            return /* :: */[
                    mk(count, a),
                    aux(t, 1)
                  ];
          }
        } else {
          return /* :: */[
                  mk(count, a),
                  /* [] */0
                ];
        }
      } else {
        return /* [] */0;
      }
    };
  };
  return aux(ll, 1);
}

var Encode = /* module */[/* encode_rle */encode_rle];

exports.last_element = last_element;
exports.last_two = last_two;
exports.at = at;
exports.length = length;
exports.reverse = reverse;
exports.is_palindrome = is_palindrome;
exports.concat = concat;
exports.flatten = flatten;
exports.flatten2 = flatten2;
exports.compress = compress;
exports.compress2 = compress2;
exports.pack = pack;
exports.encode_with_pack_rl = encode_with_pack_rl;
exports.encode_rl = encode_rl;
exports.Encode = Encode;
/* No side effect */
