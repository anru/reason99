// Generated by BUCKLESCRIPT VERSION 2.2.3, PLEASE EDIT WITH CARE
'use strict';

var Caml_obj = require("bs-platform/lib/js/caml_obj.js");

function last_element_01(_ll) {
  while(true) {
    var ll = _ll;
    if (ll) {
      var rest = ll[1];
      if (rest) {
        _ll = rest;
        continue ;
        
      } else {
        return /* Some */[ll[0]];
      }
    } else {
      return /* None */0;
    }
  };
}

function last_two_02(_ll) {
  while(true) {
    var ll = _ll;
    if (ll) {
      var rest = ll[1];
      if (rest) {
        if (rest[1]) {
          _ll = rest;
          continue ;
          
        } else {
          return /* Some */[/* tuple */[
                    ll[0],
                    rest[0]
                  ]];
        }
      } else {
        return /* None */0;
      }
    } else {
      return /* None */0;
    }
  };
}

function at_03(_k, _ll) {
  while(true) {
    var ll = _ll;
    var k = _k;
    if (k !== 0) {
      if (ll) {
        _ll = ll[1];
        _k = k - 1 | 0;
        continue ;
        
      } else {
        return /* None */0;
      }
    } else if (ll) {
      return /* Some */[ll[0]];
    } else {
      return /* None */0;
    }
  };
}

function length_04(ll) {
  if (ll) {
    return length_04(ll[1]) + 1 | 0;
  } else {
    return 0;
  }
}

function rev_05(ll) {
  var _acc = ll;
  var _result = /* [] */0;
  while(true) {
    var result = _result;
    var acc = _acc;
    if (acc) {
      _result = /* :: */[
        acc[0],
        result
      ];
      _acc = acc[1];
      continue ;
      
    } else {
      return result;
    }
  };
}

function is_palindrome(ll) {
  return Caml_obj.caml_equal(rev_05(ll), ll);
}

exports.last_element_01 = last_element_01;
exports.last_two_02 = last_two_02;
exports.at_03 = at_03;
exports.length_04 = length_04;
exports.rev_05 = rev_05;
exports.is_palindrome = is_palindrome;
/* No side effect */
